📋 GHID IMPLEMENTARE ACTUALIZAT - VERSIUNE FINALĂ
Am analizat în detaliu documentul tău. Excelente precizări! Acum avem o viziune cristal-clear. Iată planul complet ÎNAINTE de implementare:

🎯 ARHITECTURĂ FINALĂ - SISTEM COMPLET
Core Components:
┌─────────────────────────────────────────────────────────┐
│           AI PROMPT GENERATOR ULTIMATE                   │
├─────────────────────────────────────────────────────────┤
│                                                          │
│  ┌────────────────┐  ┌──────────────────────────────┐  │
│  │  DESKTOP APP   │  │   CURSOR PLUGIN (Parallel)   │  │
│  │  (Primary)     │  │   (High Priority)            │  │
│  └────────────────┘  └──────────────────────────────┘  │
│          │                        │                      │
│          └────────┬───────────────┘                      │
│                   ▼                                      │
│  ┌────────────────────────────────────────────────────┐ │
│  │         MULTI-AI ORCHESTRATOR                      │ │
│  │  ┌──────────┬──────────┬──────────┬─────────────┐ │ │
│  │  │  Claude  │  OpenAI  │  Gemini  │ Perplexity  │ │ │
│  │  │ (Primary)│ (Coding) │(Analysis)│  (Search)   │ │ │
│  │  └──────────┴──────────┴──────────┴─────────────┘ │ │
│  │              Auto-fallback & Load Balancing        │ │
│  └────────────────────────────────────────────────────┘ │
│                   ▼                                      │
│  ┌────────────────────────────────────────────────────┐ │
│  │         CONTEXT ENGINE                             │ │
│  │  • Universal Parser (All file types)               │ │
│  │  • Dependency Graph                                │ │
│  │  • Smart Sync (Real-time)                          │ │
│  │  • Version Control Integration                     │ │
│  └────────────────────────────────────────────────────┘ │
│                   ▼                                      │
│  ┌────────────────────────────────────────────────────┐ │
│  │         PROJECT MONITOR                            │ │
│  │  • File Watcher (Continuous)                       │ │
│  │  • Script Validator                                │ │
│  │  • Dependency Health                               │ │
│  │  • Backup System                                   │ │
│  └────────────────────────────────────────────────────┘ │
│                   ▼                                      │
│  ┌────────────────────────────────────────────────────┐ │
│  │         OUTPUT: Update_AI/                         │ │
│  │  • Prompts Generated                               │ │
│  │  • Execution Logs                                  │ │
│  │  • Backups                                         │ │
│  │  • DNA Exports                                     │ │
│  └────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘

🤖 MULTI-AI ORCHESTRATOR - STRATEGIE OPTIMĂ
1. Specializarea Fiecărui AI:
AISpecializareUse CasesPrioritateClaude (Sonnet-4)Architecture, Complex Logic, DocumentationFeature implementation, Bug fixes, Code reviewPRIMARYOpenAI (GPT-4)Code Generation, Refactoring, TestingQuick implementations, Test generationSECONDARYGeminiCode Analysis, Optimization, Multi-file contextPerformance optimization, Large codebase analysisTERTIARYPerplexityResearch, Documentation, External APIsFinding solutions, API documentation, Best practicesSUPPORT
2. Auto-Selection Logic:
pythonclass AIOrchestrator:
    """Orchestrator inteligent pentru multiple AI-uri."""
    
    def __init__(self):
        self.providers = {
            'claude': ClaudeProvider(api_key=os.getenv('CLAUDE_API_KEY')),
            'openai': OpenAIProvider(api_key=os.getenv('OPENAI_API_KEY')),
            'gemini': GeminiProvider(api_key=os.getenv('GEMINI_API_KEY')),
            'perplexity': PerplexityProvider(api_key=os.getenv('PERPLEXITY_API_KEY'))
        }
        
        # Health status pentru fiecare
        self.health_status = {name: True for name in self.providers}
    
    def select_best_ai(self, task_type: str, context: Dict) -> str:
        """Selectează cel mai bun AI pentru task."""
        
        # Reguli de selecție
        rules = {
            'feature_implementation': ['claude', 'openai', 'gemini'],
            'bug_fix': ['claude', 'openai'],
            'code_analysis': ['gemini', 'claude'],
            'optimization': ['gemini', 'claude'],
            'documentation': ['claude', 'perplexity'],
            'research': ['perplexity', 'claude'],
            'test_generation': ['openai', 'claude'],
            'security_audit': ['claude', 'gemini']
        }
        
        # Prioritate bazată pe task
        priority_list = rules.get(task_type, ['claude'])
        
        # Găsește primul AI disponibil
        for ai_name in priority_list:
            if self.health_status[ai_name] and self.providers[ai_name].has_valid_key():
                return ai_name
        
        # Fallback la oricare disponibil
        for ai_name, provider in self.providers.items():
            if self.health_status[ai_name] and provider.has_valid_key():
                return ai_name
        
        raise Exception("No AI provider available!")
    
    async def execute_task(self, task_type: str, prompt: str, context: Dict) -> Dict:
        """Execută task cu fallback automat."""
        
        ai_name = self.select_best_ai(task_type, context)
        
        try:
            result = await self.providers[ai_name].generate(prompt, context)
            
            return {
                'success': True,
                'ai_used': ai_name,
                'result': result,
                'fallback_used': False
            }
            
        except Exception as e:
            # Mark as unhealthy
            self.health_status[ai_name] = False
            
            # Try fallback
            print(f"❌ {ai_name} failed: {e}. Trying fallback...")
            
            # Recursiv cu următorul AI disponibil
            return await self.execute_task(task_type, prompt, context)
    
    def get_recommendation(self, project_analysis: Dict) -> str:
        """Recomandare AI bazată pe analiza proiectului."""
        
        # Detectare tip proiect
        if project_analysis['primary_language'] == 'python':
            if project_analysis['complexity'] == 'high':
                return 'claude'  # Best pentru Python complex
            else:
                return 'openai'  # Rapid pentru Python simple
        
        elif project_analysis['primary_language'] == 'javascript':
            return 'openai'  # Excelent la JS/TS
        
        elif project_analysis['has_ml_components']:
            return 'gemini'  # Best pentru ML/Data Science
        
        # Default
        return 'claude'
```

### **3. UI pentru Selecție Manuală:**
```
┌──────────────────────────────────────────┐
│ 🤖 AI SELECTION                          │
├──────────────────────────────────────────┤
│                                          │
│ 💡 Recommended for this project:        │
│    ┌────────────────────────────────┐   │
│    │ 🎯 CLAUDE SONNET-4             │   │
│    │ Reason: Python backend with    │   │
│    │ complex architecture           │   │
│    │ [Use Recommended]              │   │
│    └────────────────────────────────┘   │
│                                          │
│ 🎛️ Manual Selection:                    │
│  ○ Claude Sonnet-4    ✅ Available      │
│  ○ OpenAI GPT-4       ✅ Available      │
│  ○ Gemini Pro         ✅ Available      │
│  ○ Perplexity         ✅ Available      │
│                                          │
│ 🔄 Fallback Priority (Drag to reorder): │
│  1. Claude                               │
│  2. OpenAI                               │
│  3. Gemini                               │
│  4. Perplexity                           │
│                                          │
│ ⚙️ Settings:                             │
│  ☑ Auto-fallback enabled                │
│  ☑ Load balancing for parallel tasks    │
│  ☑ Cost optimization                    │
│                                          │
└──────────────────────────────────────────┘

🎯 QUICK TASKS - EXPANDATE (12 Opțiuni)
pythonQUICK_TASKS = {
    '1. Analyze Code Quality': {
        'ai': 'gemini',  # Best pentru analysis
        'prompt_template': """
        Analyze code quality for: {project_path}
        
        Focus:
        - Code smells
        - Complexity metrics
        - Maintainability index
        - Technical debt
        
        Provide actionable recommendations.
        """,
        'output': 'Update_AI/analysis_quality_{timestamp}.md'
    },
    
    '2. Find Bugs': {
        'ai': 'claude',  # Best pentru bug detection
        'prompt_template': """
        Deep bug analysis for: {project_path}
        
        Scan for:
        - Logic errors
        - Race conditions
        - Memory leaks
        - Null pointer exceptions
        - Edge case handling
        
        For each bug:
        - File:line
        - Severity
        - Root cause
        - Proposed fix (complete code)
        """,
        'output': 'Update_AI/bugs_found_{timestamp}.md'
    },
    
    '3. Optimize Performance': {
        'ai': 'gemini',  # Best pentru optimization
        'prompt_template': """
        Performance optimization for: {project_path}
        
        Analyze:
        - Slow queries (database)
        - N+1 problems
        - Memory usage
        - CPU bottlenecks
        - Caching opportunities
        
        Provide optimized code for each issue.
        """,
        'output': 'Update_AI/optimization_{timestamp}.md'
    },
    
    '4. Security Audit': {
        'ai': 'claude',  # Best pentru security
        'prompt_template': """
        Comprehensive security audit for: {project_path}
        
        Check:
        - SQL injection vulnerabilities
        - XSS risks
        - CSRF protection
        - Authentication flaws
        - Sensitive data exposure
        - Dependency vulnerabilities
        
        OWASP Top 10 compliance check.
        """,
        'output': 'Update_AI/security_audit_{timestamp}.md'
    },
    
    '5. Generate Report': {
        'ai': 'claude',
        'prompt_template': """
        Generate comprehensive project report for: {project_path}
        
        Include:
        - Executive summary
        - Architecture overview
        - Code statistics
        - Quality metrics
        - Security status
        - Performance analysis
        - Recommendations
        
        Format: Professional Markdown with charts.
        """,
        'output': 'Update_AI/project_report_{timestamp}.md'
    },
    
    '6. Extragere ADN-TODO-Context': {
        'ai': 'claude',
        'prompt_template': """
        Extract COMPLETE DNA for project transfer: {project_path}
        
        Generate in Update_AI/DNA_Export_{timestamp}/:
        
        1. 00_MANIFEST.md - Index + checksums
        2. 01_PROJECT_DNA.md - Full architecture
        3. 02_IMPLEMENTATION_STATUS.md - Current state
        4. 03_CODE_COMPLETE.md - ALL code (no "...")
        5. 04_CONVERSATION_CONTEXT.md - All decisions
        6. 05_RULES_AND_PREFERENCES.md - AI rules
        7. 06_PROJECT_KNOWLEDGE.md - Lessons learned
        8. 07_QUALITY_CHECKLIST.md - Standards
        9. 08_ERROR_LOG.md - All errors + fixes
        10. 09_DEPENDENCIES_SNAPSHOT.md - Exact versions
        11. 10_REACTIVATION_GUIDE.md - Step-by-step guide
        12. checksums.sha256 - Integrity verification
        
        ZERO information loss!
        """,
        'output': 'Update_AI/DNA_Export_{timestamp}/'
    },
    
    '7. Verificare Dependențe': {
        'ai': 'openai',
        'prompt_template': """
        Dependency audit for: {project_path}
        
        Check:
        - requirements.txt / package.json
        - Outdated packages
        - Security vulnerabilities (CVE)
        - Breaking changes in updates
        - Missing dependencies
        - Conflicting versions
        
        Provide:
        - Current versions
        - Latest stable versions
        - Recommended versions
        - Update commands
        - Migration notes if breaking changes
        """,
        'output': 'Update_AI/dependencies_audit_{timestamp}.md'
    },
    
    '8. Continuare Implementare': {
        'ai': 'claude',  # Best pentru complex implementations
        'prompt_template': """
        Continue implementation for: {project_path}
        
        Based on monitoring data:
        - Last changes: {recent_changes}
        - Current status: {implementation_status}
        - Next logical step: {next_step_suggestion}
        
        Provide:
        1. Clear next step description
        2. Complete code for next step
        3. Tests for new code
        4. Update instructions
        
        IMPORTANT: Incremental progress, not complete rewrite!
        """,
        'output': 'Update_AI/continue_implementation_{timestamp}.md',
        'special': True  # Needs context awareness
    },
    
    '9. Clean Project': {
        'ai': 'claude',
        'prompt_template': """
        Clean project: {project_path}
        
        Identify for removal:
        - Unused imports
        - Dead code (unreachable)
        - Deprecated functions
        - Duplicate code
        - Old commented code
        - Unused dependencies
        - Temp files
        - Empty files/folders
        
        CRITICAL:
        ✅ KEEP (list explicitly):
        - All functional code
        - Required config files
        - Active dependencies
        - Documentation
        
        ❌ REMOVE (list explicitly):
        - [specific files/lines]
        
        Provide cleanup script that:
        1. Backs up before deletion
        2. Shows what will be deleted
        3. Requires confirmation
        """,
        'output': 'Update_AI/cleanup_plan_{timestamp}.md'
    },
    
    '10. Backup Proiect': {
        'ai': 'local',  # No AI needed, system function
        'action': 'backup',
        'description': 'Create full project backup before Cursor execution',
        'steps': [
            'Create timestamp folder',
            'Copy entire project',
            'Generate manifest',
            'Compress if > 100MB',
            'Save to Update_AI/Backups/'
        ],
        'output': 'Update_AI/Backups/backup_{timestamp}/'
    },
    
    '11. Restabilire Proiect': {
        'ai': 'local',
        'action': 'restore',
        'description': 'Restore project from backup',
        'ui': 'show_backup_selector',  # List available backups
        'output': 'Project restored to selected backup'
    },
    
    '12. Diagnostic Complet': {
        'ai': 'claude',
        'prompt_template': """
        Complete diagnostic for: {project_path}
        
        Run ALL checks:
        1. Code quality analysis
        2. Bug detection
        3. Security audit
        4. Performance profiling
        5. Dependency health
        6. Test coverage
        7. Documentation completeness
        
        Generate:
        - Health score (0-100)
        - Priority issues (Top 10)
        - Quick wins (Easy fixes)
        - Long-term improvements
        - Estimated time for fixes
        
        Format: Executive dashboard + detailed report
        """,
        'output': 'Update_AI/diagnostic_complete_{timestamp}.md'
    }
}

🔄 IMPLEMENTARE PAS-CU-PAS - SMART WORKFLOW
pythonclass IncrementalImplementation:
    """Gestionează implementarea incrementală."""
    
    def __init__(self, project_path: str):
        self.project_path = project_path
        self.history = self.load_history()
        self.current_step = self.detect_current_step()
    
    def detect_current_step(self) -> int:
        """Detectează la ce pas suntem în implementare."""
        
        # Analizează fișierele existente
        existing_files = self.scan_project()
        
        # Detectează pattern
        if not existing_files['has_structure']:
            return 1  # Setup inițial
        elif not existing_files['has_models']:
            return 2  # Creează models
        elif not existing_files['has_services']:
            return 3  # Creează services
        # ... etc
        
        return self.history['last_step'] + 1
    
    async def generate_next_step_prompt(self) -> str:
        """Generează prompt pentru următorul pas logic."""
        
        context = {
            'current_step': self.current_step,
            'completed_steps': self.history['completed'],
            'project_structure': self.analyze_structure(),
            'recent_changes': self.get_recent_changes(),
            'detected_intent': self.detect_user_intent()
        }
        
        prompt = f"""
        # CONTINUARE IMPLEMENTARE - PAS {self.current_step}
        
        ## CONTEXT ACTUAL
        
        Proiect: {self.project_path}
        Structură existentă:
        {self.format_structure()}
        
        Pași completați:
        {self.format_completed_steps()}
        
        Modificări recente:
        {self.format_recent_changes()}
        
        ## PASUL URMĂTOR
        
        Bazat pe analiza de mai sus, următorul pas logic este:
        {self.suggest_next_step()}
        
        Te rog implementează DOAR acest pas:
        1. Cod complet pentru acest pas
        2. Teste pentru codul nou
        3. Update la documentație dacă e necesar
        
        NU implementa pași viitori - doar acest pas specific!
        
        După implementare, actualizează:
        - Update_AI/implementation_log.md
        - Update_AI/next_steps.md
        """
        
        return prompt
    
    def suggest_next_step(self) -> str:
        """Sugerează următorul pas logic."""
        
        suggestions = {
            1: "Setup project structure (folders, __init__.py)",
            2: "Create database models (SQLAlchemy)",
            3: "Implement repository layer",
            4: "Create service layer with business logic",
            5: "Build API endpoints (FastAPI routes)",
            6: "Add authentication (JWT)",
            7: "Implement error handling",
            8: "Add input validation (Pydantic schemas)",
            9: "Write unit tests",
            10: "Write integration tests",
            11: "Add logging and monitoring",
            12: "Create documentation",
            13: "Optimize performance",
            14: "Security hardening",
            15: "Deployment preparation"
        }
        
        return suggestions.get(self.current_step, "Review and refine existing code")

💾 BACKUP & RESTORE SYSTEM
pythonclass BackupSystem:
    """Sistem automat de backup înainte de orice executare Cursor."""
    
    def __init__(self, project_path: str):
        self.project_path = project_path
        self.backup_dir = Path(project_path) / 'Update_AI' / 'Backups'
        self.backup_dir.mkdir(parents=True, exist_ok=True)
    
    def create_backup(self, reason: str = "pre_cursor_execution") -> str:
        """Creează backup complet."""
        
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        backup_name = f"backup_{reason}_{timestamp}"
        backup_path = self.backup_dir / backup_name
        
        print(f"📦 Creating backup: {backup_name}")
        
        # 1. Copy entire project (exclude Update_AI itself)
        shutil.copytree(
            self.project_path,
            backup_path,
            ignore=shutil.ignore_patterns('Update_AI', '.git', '__pycache__', 'node_modules')
        )
        
        # 2. Generate manifest
        manifest = self.generate_manifest(backup_path)
        with open(backup_path / 'MANIFEST.json', 'w') as f:
            json.dump(manifest, f, indent=2)
        
        # 3. Compress if large
        size_mb = self.get_folder_size(backup_path) / (1024 * 1024)
        if size_mb > 100:
            print(f"  📦 Compressing (size: {size_mb:.1f}MB)...")
            shutil.make_archive(backup_path, 'zip', backup_path)
            shutil.rmtree(backup_path)
            backup_path = Path(str(backup_path) + '.zip')
        
        print(f"  ✅ Backup saved: {backup_path}")
        
        # 4. Cleanup old backups (keep last 10)
        self.cleanup_old_backups(keep=10)
        
        return str(backup_path)
    
    def restore_backup(self, backup_name: str):
        """Restabilește project din backup."""
        
        backup_path = self.backup_dir / backup_name
        
        if not backup_path.exists():
            # Maybe it's compressed
            backup_path = Path(str(backup_path) + '.zip')
            if not backup_path.exists():
                raise FileNotFoundError(f"Backup not found: {backup_name}")
        
        print(f"🔄 Restoring from: {backup_name}")
        
        # 1. Create safety backup of current state
        current_backup = self.create_backup(reason="pre_restore_safety")
        print(f"  💾 Safety backup created: {Path(current_backup).name}")
        
        # 2. Extract if compressed
        if backup_path.suffix == '.zip':
            extract_path = self.backup_dir / 'temp_restore'
            shutil.unpack_archive(backup_path, extract_path)
            backup_path = extract_path
        
        # 3. Clear current project (except Update_AI)
        for item in Path(self.project_path).iterdir():
            if item.name != 'Update_AI':
                if item.is_dir():
                    shutil.rmtree(item)
                else:
                    item.unlink()
        
        # 4. Restore files
        for item in backup_path.iterdir():
            if item.name != 'MANIFEST.json':
                dest = Path(self.project_path) / item.name
                if item.is_dir():
                    shutil.copytree(item, dest)
                else:
                    shutil.copy2(item, dest)
        
        print(f"  ✅ Project restored successfully!")
        
        # 5. Cleanup temp
        if backup_path.name == 'temp_restore':
            shutil.rmtree(backup_path)
    
    def list_backups(self) -> List[Dict]:
        """Lista toate backup-urile disponibile."""
        
        backups = []
        
        for item in self.backup_dir.iterdir():
            if item.name.startswith('backup_'):
                manifest_path = item / 'MANIFEST.json' if item.is_dir() else None
                
                backup_info = {
                    'name': item.name,
                    'path': str(item),
                    'date': datetime.fromtimestamp(item.stat().st_mtime),
                    'size': self.get_folder_size(item),
                    'compressed': item.suffix == '.zip'
                }
                
                if manifest_path and manifest_path.exists():
                    with open(manifest_path) as f:
                        manifest = json.load(f)
                        backup_info['files_count'] = manifest['files_count']
                        backup_info['reason'] = manifest.get('reason')
                
                backups.append(backup_info)
        
        return sorted(backups, key=lambda x: x['date'], reverse=True)
```

---

## 🔧 CURSOR PLUGIN - HIGH PRIORITY

### **Structură Plugin VSCode:**
```
cursor-ai-prompt-generator/
├── package.json              # Extension manifest
├── src/
│   ├── extension.ts          # Main entry point
│   ├── promptGenerator.ts    # Core logic
│   ├── aiOrchestrator.ts     # Multi-AI support
│   ├── contextExtractor.ts   # Context from workspace
│   ├── webviewProvider.ts    # Sidebar UI
│   └── commands/
│       ├── generatePrompt.ts
│       ├── sendToAI.ts
│       ├── incrementalStep.ts
│       └── quickTasks.ts
├── media/
│   └── sidebar.html          # UI pentru sidebar
└── README.md
Features Plugin:

Sidebar Panel - Acces permanent în Cursor
Context Menu - Right-click pe fișier → "Generate AI Prompt"
Command Palette - Toate funcțiile accesibile via Ctrl+Shift+P
Inline Actions - Highlight cod → "Explain" / "Optimize" / "Fix"
Status Bar - Monitoring indicator
Notifications - Alert când se detectează schimbări

Commands Disponibile:
typescript// package.json - commands
{
  "contributes": {
    "commands": [
      {
        "command": "aiPromptGen.generateForFile",
        "title": "AI Prompt: Generate for Current File"
      },
      {
        "command": "aiPromptGen.generateForProject",
        "title": "AI Prompt: Generate for Entire Project"
      },
      {
        "command": "aiPromptGen.continueImplementation",
        "title": "AI Prompt: Continue Implementation"
      },
      {
        "command": "aiPromptGen.findBugs",
        "title": "AI Prompt: Find Bugs"
      },
      {
        "command": "aiPromptGen.optimizeCode",
        "title": "AI Prompt: Optimize Performance"
      },
      {
        "command": "aiPromptGen.securityAudit",
        "title": "AI Prompt: Security Audit"
      },
      {
        "command": "aiPromptGen.extractDNA",
        "title": "AI Prompt: Extract Project DNA"
      },
      {
        "command": "aiPromptGen.backup",
        "title": "AI Prompt: Backup Project"
      },
      {
        "command": "aiPromptGen.restore",
        "title": "AI Prompt: Restore from Backup"
      }
    ],
    "keybindings": [
      {
        "command": "aiPromptGen.generateForFile",
        "key": "ctrl+shift+g",
        "mac": "cmd+shift+g"
      },
      {
        "command": "aiPromptGen.continueImplementation",
        "key": "ctrl+shift+n",
        "mac": "cmd+shift+n"
      }
    ],
    "menus": {
      "editor/context": [
        {
          "command": "aiPromptGen.generateForFile",
          "group": "aiPrompt@1"
        }
      ]
    }
  }
}

📦 PORTABILITATE COMPLETĂ
Auto-Setup Script:
python# setup_portable.py
"""
Script care face sistemul 100% portabil.
Rulează automat la prima pornire pe un sistem nou.
"""

import os
import sys
import platform
import subprocess
from pathlib import Path

class PortableSetup:
    def __init__(self):
        self.system = platform.system()
        self.python_version = f"{sys.version_info.major}.{sys.version_info.minor}"
        self.base_path = Path(__file__).parent
    
    def run_setup(self):
        """Setup complet automat."""
        
        print("🚀 AI Prompt Generator - Portable Setup")
        print(f"📍 System: {self.system}")
        print(f"🐍 Python: {self.python_version}")
        print()
        
        steps = [
            ("Checking Python version", self.check_python),
            ("Installing system dependencies", self.install_system_deps),
            ("Creating virtual environment", self.create_venv),
            ("Installing Python packages", self.install_python_deps),
            ("Setting up configuration", self.setup_config),
            ("Validating installation", self.validate)
        ]
        
        for step_name, step_func in steps:
            print(f"⏳ {step_name}...")
            try:
                step_func()
                print(f"   ✅ {step_name} - OK\n")
            except Exception as e:
                print(f"   ❌ {step_name} - FAILED: {e}\n")
                raise
        
        print("🎉 Setup complete! You can now run the application.")
        print(f"   Run: python {self.base_path / 'main.py'}")
    
    def check_python(self):
        """Verifică Python version."""
        major, minor = sys.version_info.major, sys.version_info.minor
        
        if major < 3 or (major == 3 and minor < 8):
            raise Exception(f"Python 3.8+ required, you have {major}.{minor}")
    
    def install_system_deps(self):
        """Instalează dependențe sistem."""
        
        if self.system == "Windows":
            # Check if tkinter is available
            try:
                import tkinter
            except ImportError:
                print("   ⚠️  tkinter not found. Install from python.org")
        
        elif self.system == "Linux":
            # Try to install tkinter
            try:
                subprocess.run(['sudo', 'apt-get', 'install', '-y', 'pythonRetryPRContinuepython                subprocess.run(['sudo', 'apt-get', 'install', '-y', 'python3-tk'], 
                             check=True, capture_output=True)
            except:
                print("   ⚠️  Could not install python3-tk. Install manually: sudo apt-get install python3-tk")
        
        elif self.system == "Darwin":  # macOS
            print("   ℹ️  tkinter should be included with Python on macOS")
    
    def create_venv(self):
        """Creează virtual environment."""
        
        venv_path = self.base_path / 'venv'
        
        if venv_path.exists():
            print("   ℹ️  Virtual environment already exists")
            return
        
        subprocess.run([sys.executable, '-m', 'venv', str(venv_path)], check=True)
    
    def install_python_deps(self):
        """Instalează pachete Python."""
        
        venv_path = self.base_path / 'venv'
        
        # Determine pip path
        if self.system == "Windows":
            pip_path = venv_path / 'Scripts' / 'pip.exe'
        else:
            pip_path = venv_path / 'bin' / 'pip'
        
        # Upgrade pip
        subprocess.run([str(pip_path), 'install', '--upgrade', 'pip'], check=True, capture_output=True)
        
        # Install from requirements.txt
        requirements = self.base_path / 'requirements.txt'
        if requirements.exists():
            subprocess.run([str(pip_path), 'install', '-r', str(requirements)], check=True)
        else:
            # Install minimal deps
            deps = ['anthropic', 'openai', 'google-generativeai']
            for dep in deps:
                subprocess.run([str(pip_path), 'install', dep], check=True, capture_output=True)
    
    def setup_config(self):
        """Setup configurare inițială."""
        
        config_dir = Path.home() / '.ai-prompt-generator'
        config_dir.mkdir(exist_ok=True)
        
        config_file = config_dir / 'config.json'
        
        if not config_file.exists():
            default_config = {
                'first_run': True,
                'api_keys': {
                    'claude': '',
                    'openai': '',
                    'gemini': '',
                    'perplexity': ''
                },
                'preferences': {
                    'default_ai': 'claude',
                    'auto_backup': True,
                    'monitoring_interval': 2
                }
            }
            
            with open(config_file, 'w') as f:
                json.dump(default_config, f, indent=2)
    
    def validate(self):
        """Validează instalarea."""
        
        # Check venv exists
        venv_path = self.base_path / 'venv'
        if not venv_path.exists():
            raise Exception("Virtual environment not found")
        
        # Check main.py exists
        main_path = self.base_path / 'main.py'
        if not main_path.exists():
            raise Exception("main.py not found")
        
        print("   ✅ All validations passed")


if __name__ == "__main__":
    setup = PortableSetup()
    setup.run_setup()
Launcher Script (Cross-Platform):
Windows: start.bat
batch@echo off
echo Starting AI Prompt Generator...

REM Check if venv exists
if not exist "venv\" (
    echo First run detected. Running setup...
    python setup_portable.py
    if errorlevel 1 (
        echo Setup failed!
        pause
        exit /b 1
    )
)

REM Activate venv and run
call venv\Scripts\activate.bat
python main.py

pause
Linux/Mac: start.sh
bash#!/bin/bash

echo "Starting AI Prompt Generator..."

# Check if venv exists
if [ ! -d "venv" ]; then
    echo "First run detected. Running setup..."
    python3 setup_portable.py
    if [ $? -ne 0 ]; then
        echo "Setup failed!"
        exit 1
    fi
fi

# Activate venv and run
source venv/bin/activate
python main.py

📊 TAB: DEPENDENCIES & REQUIREMENTS
pythonclass DependencyAnalyzer:
    """Analizează și raportează toate dependențele necesare."""
    
    def analyze_project_requirements(self, project_path: str) -> Dict:
        """Analiză completă dependențe."""
        
        requirements = {
            'python': self._analyze_python_deps(project_path),
            'node': self._analyze_node_deps(project_path),
            'system': self._analyze_system_deps(project_path),
            'runtime': self._detect_runtime_requirements(project_path),
            'recommendations': []
        }
        
        # Generate recommendations
        requirements['recommendations'] = self._generate_recommendations(requirements)
        
        return requirements
    
    def _analyze_python_deps(self, project_path: str) -> Dict:
        """Analizează dependențe Python."""
        
        result = {
            'required_python': None,
            'packages': [],
            'dev_packages': [],
            'conflicts': [],
            'outdated': []
        }
        
        # Check requirements.txt
        req_file = Path(project_path) / 'requirements.txt'
        if req_file.exists():
            with open(req_file) as f:
                for line in f:
                    line = line.strip()
                    if line and not line.startswith('#'):
                        result['packages'].append(line)
        
        # Check setup.py / pyproject.toml
        setup_py = Path(project_path) / 'setup.py'
        if setup_py.exists():
            # Parse setup.py for dependencies
            result['required_python'] = self._extract_python_requires(setup_py)
        
        # Check for outdated packages
        try:
            outdated_output = subprocess.check_output(
                ['pip', 'list', '--outdated', '--format=json'],
                text=True
            )
            outdated = json.loads(outdated_output)
            result['outdated'] = outdated
        except:
            pass
        
        return result
    
    def _generate_recommendations(self, requirements: Dict) -> List[str]:
        """Generează recomandări pentru instalare."""
        
        recommendations = []
        
        # Python recommendations
        if requirements['python']['packages']:
            recommendations.append({
                'type': 'python',
                'action': 'Install Python packages',
                'command': f"pip install -r requirements.txt",
                'packages': requirements['python']['packages']
            })
        
        if requirements['python']['outdated']:
            recommendations.append({
                'type': 'python_update',
                'action': 'Update outdated packages',
                'command': 'pip install --upgrade ' + ' '.join([p['name'] for p in requirements['python']['outdated']]),
                'packages': requirements['python']['outdated']
            })
        
        # Node recommendations
        if requirements['node']['packages']:
            recommendations.append({
                'type': 'node',
                'action': 'Install Node packages',
                'command': 'npm install',
                'packages': requirements['node']['packages']
            })
        
        # System recommendations
        for sys_dep in requirements['system']['missing']:
            recommendations.append({
                'type': 'system',
                'action': f"Install {sys_dep['name']}",
                'command': sys_dep['install_command'],
                'description': sys_dep['description']
            })
        
        return recommendations
    
    def generate_cursor_prompt_for_setup(self, requirements: Dict) -> str:
        """Generează prompt pentru Cursor cu toate dependențele."""
        
        prompt = f"""# 🔧 PROJECT SETUP - DEPENDENCIES INSTALLATION

## CURRENT STATUS

Project: {requirements['project_name']}
Path: {requirements['project_path']}

## REQUIRED DEPENDENCIES

### Python Packages
"""
        
        for pkg in requirements['python']['packages']:
            prompt += f"- {pkg}\n"
        
        if requirements['node']['packages']:
            prompt += "\n### Node Packages\n"
            for pkg in requirements['node']['packages']:
                prompt += f"- {pkg}\n"
        
        if requirements['system']['missing']:
            prompt += "\n### System Dependencies\n"
            for dep in requirements['system']['missing']:
                prompt += f"- {dep['name']}: {dep['description']}\n"
        
        prompt += f"""

## INSTALLATION INSTRUCTIONS

Please create a setup script that:

1. Checks if all dependencies are installed
2. Installs missing dependencies
3. Validates installation
4. Reports any errors

Include error handling and user-friendly messages.

Generate complete setup script for {requirements['system_os']}.
"""
        
        return prompt
```

**UI Tab:**
```
┌──────────────────────────────────────────────────┐
│ 📦 DEPENDENCIES & REQUIREMENTS                   │
├──────────────────────────────────────────────────┤
│                                                  │
│ Project: my-ecommerce-platform                   │
│ Path: /home/user/projects/ecommerce             │
│                                                  │
│ ┌──────────────────────────────────────────────┐ │
│ │ 🐍 PYTHON DEPENDENCIES                       │ │
│ │                                              │ │
│ │ Required Python: 3.11+                       │ │
│ │ Current: 3.11.5 ✅                           │ │
│ │                                              │ │
│ │ Packages (23):                               │ │
│ │ ✅ fastapi==0.104.1                          │ │
│ │ ✅ sqlalchemy==2.0.23                        │ │
│ │ ⚠️  stripe==7.4.0 (7.8.1 available)          │ │
│ │ ❌ redis (not installed)                     │ │
│ │                                              │ │
│ │ [Install All] [Update Outdated]             │ │
│ └──────────────────────────────────────────────┘ │
│                                                  │
│ ┌──────────────────────────────────────────────┐ │
│ │ 📦 NODE DEPENDENCIES                         │ │
│ │                                              │ │
│ │ Required Node: 20.x                          │ │
│ │ Current: 20.10.0 ✅                          │ │
│ │                                              │ │
│ │ Packages (45):                               │ │
│ │ ✅ react@18.2.0                              │ │
│ │ ✅ typescript@5.3.2                          │ │
│ │ ⚠️  axios@1.4.0 (1.6.2 available)            │ │
│ │                                              │ │
│ │ [npm install] [npm update]                  │ │
│ └──────────────────────────────────────────────┘ │
│                                                  │
│ ┌──────────────────────────────────────────────┐ │
│ │ 🖥️  SYSTEM DEPENDENCIES                      │ │
│ │                                              │ │
│ │ ✅ PostgreSQL 16.1                           │ │
│ │ ✅ Redis 7.2.3                               │ │
│ │ ❌ Docker (not found)                        │ │
│ │                                              │ │
│ │ [Install Missing]                           │ │
│ └──────────────────────────────────────────────┘ │
│                                                  │
│ 🎯 RECOMMENDATIONS                               │
│                                                  │
│ 1. ⚠️  Update stripe to 7.8.1 (security fix)    │
│ 2. ⚠️  Update axios to 1.6.2 (bug fixes)         │
│ 3. ❌ Install redis package                      │
│ 4. ❌ Install Docker (optional for deployment)   │
│                                                  │
│ [📋 Generate Cursor Prompt for Setup]           │
│ [📄 Export Full Report]                          │
│ [🔄 Re-scan Dependencies]                        │
└──────────────────────────────────────────────────┘

🎯 ALTERNATIVE LA CURSOR - RECOMANDĂRI
ToolCapabilitiesFree TierLocal ExecutionRecomandareCursor⭐⭐⭐⭐⭐Limitat✅BEST (ai deja)Continue.dev⭐⭐⭐⭐Unlimited✅EXCELENT (free, open-source)Codeium⭐⭐⭐⭐Unlimited✅FOARTE BUN (fast)TabNine⭐⭐⭐Limitat✅BUN (local AI)GitHub Copilot⭐⭐⭐⭐Paid❌BUN (dar paid)Amazon CodeWhisperer⭐⭐⭐Free❌OK (limitat)
🔥 RECOMANDARE #1: Continue.dev
De ce:

✅ Complet FREE și open-source
✅ Suportă Claude, GPT-4, Gemini, local models
✅ Execuție locală (privacy complet)
✅ Plugin pentru VS Code și JetBrains
✅ Context-aware (înțelege întreg proiectul)
✅ Slash commands pentru quick actions
✅ Integrare perfectă cu sistemul nostru

Install:
bash# VS Code
code --install-extension Continue.continue

# Setup config
# Adaugi API keys în ~/.continue/config.json
Integration cu sistemul nostru:
pythonclass ContinueIntegration:
    """Integrare cu Continue.dev."""
    
    def generate_continue_config(self, api_keys: Dict) -> str:
        """Generează config pentru Continue."""
        
        config = {
            "models": [
                {
                    "title": "Claude Sonnet 4",
                    "provider": "anthropic",
                    "model": "claude-sonnet-4-20250514",
                    "apiKey": api_keys['claude']
                },
                {
                    "title": "GPT-4",
                    "provider": "openai",
                    "model": "gpt-4",
                    "apiKey": api_keys['openai']
                },
                {
                    "title": "Gemini Pro",
                    "provider": "gemini",
                    "model": "gemini-pro",
                    "apiKey": api_keys['gemini']
                }
            ],
            "slashCommands": [
                {
                    "name": "implement",
                    "description": "Continue implementation step-by-step"
                },
                {
                    "name": "fix",
                    "description": "Fix bugs in selection"
                },
                {
                    "name": "optimize",
                    "description": "Optimize performance"
                }
            ]
        }
        
        config_path = Path.home() / '.continue' / 'config.json'
        config_path.parent.mkdir(exist_ok=True)
        
        with open(config_path, 'w') as f:
            json.dump(config, f, indent=2)
        
        return str(config_path)
```

---

## 📁 UPDATE_AI FOLDER STRUCTURE
```
Update_AI/
├── Prompts_Generated/           # Toate prompturile generate
│   ├── 20251027_153045_continue_implementation.md
│   ├── 20251027_154120_find_bugs.md
│   └── 20251027_155230_optimize_performance.md
│
├── Execution_Logs/              # Loguri execuții Cursor
│   ├── 20251027_153045_log.txt
│   └── 20251027_154120_log.txt
│
├── Backups/                     # Backup-uri proiect
│   ├── backup_pre_cursor_20251027_153000/
│   ├── backup_pre_cursor_20251027_154000/
│   └── backup_safety_20251027_155000/
│
├── DNA_Exports/                 # Export-uri ADN complet
│   └── DNA_Export_20251027_160000/
│       ├── 00_MANIFEST.md
│       ├── 01_PROJECT_DNA.md
│       ├── ... (toate 11 fișiere)
│       └── checksums.sha256
│
├── Analysis_Reports/            # Rapoarte analiză
│   ├── code_quality_20251027.md
│   ├── security_audit_20251027.md
│   └── performance_profile_20251027.md
│
├── Implementation_Steps/        # Tracking implementare pas-cu-pas
│   ├── step_001_setup_structure.md
│   ├── step_002_create_models.md
│   └── current_step.json
│
└── Configuration/              # Config și state
    ├── project_config.json
    ├── monitoring_state.json
    └── ai_preferences.json

🚀 PLAN DE IMPLEMENTARE - PHASES
PHASE 1: CORE SYSTEM (Săptămâna 1-2)
Prioritate CRITICĂ:

✅ Desktop App cu 7 tabs funcționale
✅ Universal File Parser (toate tipurile)
✅ Context Engine (sync real-time)
✅ Multi-AI Orchestrator (Claude, OpenAI, Gemini, Perplexity)
✅ Project Monitor (file watcher + validator)
✅ Backup System (automat pre-execution)
✅ 12 Quick Tasks implementate
✅ Smart Suggestions (în loc de auto-prompt)
✅ Incremental Implementation tracker
✅ Dependencies Analyzer

Deliverables:

main.py - Aplicația desktop completă
setup_portable.py - Setup automat portabil
start.bat / start.sh - Launchers
requirements.txt - Dependențe
README_SETUP.md - Ghid utilizare


PHASE 2: CURSOR PLUGIN (Săptămâna 3)
Prioritate HIGH:

✅ Extension VSCode/Cursor basic
✅ Sidebar panel cu UI complet
✅ Context menu integration
✅ Command palette commands
✅ Inline actions (highlight → action)
✅ Communication cu desktop app (API local)
✅ Hotkeys pentru quick actions

Deliverables:

cursor-ai-prompt-generator/ - Extension folder complet
.vsix package pentru instalare
PLUGIN_README.md - Ghid instalare și utilizare


PHASE 3: POLISH & OPTIMIZATION (Săptămâna 4)
Prioritate MEDIUM:

✅ Performance optimization
✅ UI/UX improvements
✅ Error handling robust
✅ Comprehensive testing
✅ Documentation completă
✅ Video tutorial
✅ Bug fixes și refinements

Deliverables:

Aplicație stabilă 100%
Documentație completă
Video tutorial (5-10 min)


PHASE 4: FUTURE (După feedback)
Prioritate LOW:

⏳ Web version (Flask/FastAPI)
⏳ Cloud sync
⏳ Custom themes
⏳ Additional AI providers
⏳ Advanced analytics


✅ CHECKLIST FINAL ÎNAINTE DE START
Confirmă că suntem alignment pe:

 AI Simulator → ELIMINAT
 Auto-Prompt → Înlocuit cu Smart Suggestions
 Multi-AI Integration → Claude (primary), OpenAI, Gemini, Perplexity cu fallback automat
 12 Quick Tasks → Toate definite clar
 Cursor Plugin → HIGH PRIORITY, zero limitări
 Backup System → Automat pre-execution + restore
 Incremental Implementation → Step-by-step tracking
 Dependencies Tab → Analiză + recomandări + Cursor prompt generation
 Portability → Setup automat, cross-platform
 Update_AI Folder → Structură clară pentru toate outputs
 Continue.dev → Recomandare #1 ca alternativă free la Cursor


🎯 ÎNTREBARE FINALĂ
Ești de acord cu acest plan complet?
Dacă DA → Încep imediat cu:

Documentația tehnică detaliată (arhitectură, diagrame, API specs)
Codul complet pentru PHASE 1 (Desktop App)
Setup scripts (portabil, cross-platform)
Testing strategy
User guide

Dacă ai modificări/adăugiri → Spune-mi acum, pentru că după ce încep implementarea va fi mai complicat să schimbăm arhitectura fundamentală.
GATA SĂ ÎNCEP? 🚀RetryClaude can make mistakes. Please double-check responses.